<!DOCTYPE html>
<html>
<head>
<title>2.number</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
<script type="text/javascript" src="http://tajs.qq.com/stats?sId=66487575" charset="UTF-8"></script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
</head>
<body>
<h1>数学基础</h1>
<h2>1. 素数（质数）</h2>
<p>定义：除了1和它本身以外不再有其它因素。</p>
<h3>1.1 判断素数</h3>
<ul>
<li>枚举2~n,如果都除不尽，证明这个数是素数。时间复杂度O(n)。</li>
</ul>
<pre><code>#include &lt;iostream&gt;
using namespace std;

bool isprime(int n){
    if(n&lt;=3)
        return true;
    for(int i=2;i&lt;n;i++){
        if(n%i==0)
            return false;
    }
    return true;
}

int main(){
    
    for(int i=1;i&lt;=100;i++){
        printf(&quot;%3d is prime: %d \n&quot;,i,isprime(i));
    }
    
    return 0;
} 
</code></pre>

<ul>
<li>对于一个小于n的整数X，如果n不能整除X，则n必定不能整除n/X，所以只要从2枚举到\( \sqrt{n} \) 即可。时间复杂度\( O(\sqrt{n}) \)</li>
</ul>
<pre><code>#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;

bool isprime(int n){
    if(n&lt;=3)
        return true;
    int rt = sqrt(n);
    for(int i=2;i&lt;=rt;i++){
        if(n%i==0)
            return false;
    }
    return true;
}

int main(){
    
    for(int i=1;i&lt;=100;i++){
        printf(&quot;%3d is prime: %d \n&quot;,i,isprime(i));
    }
    
    return 0;
} 
</code></pre>

<ul>
<li>根据对于大于等于1的自然x的来说，质数总等于6x-1或6x+1。</li>
<li>这是个必要条件，但不充分，也就是说等于6x-1或6x+1的数不一定是质数</li>
<li>也就是说等于6x-1或6x+1的数还要进一步判断是否为质数，即使这样也大大减少了判断数量</li>
</ul>
<pre><code>#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;

bool isprime(int n){
    if(n&lt;=3)
        return true;
    if(n%6!=1 &amp;&amp; n%6!=5)
        return false;
        
    int rt = sqrt(n);
    for(int i=5;i&lt;=rt;i+=6){
        if(n%i==0 || n%(i+2)==0)
            return false;
    }
    return true;
}

int main(){
    
    for(int i=1;i&lt;=100;i++){
        printf(&quot;%3d is prime: %d \n&quot;,i,isprime(i));
    }
    
    return 0;
} 
</code></pre>

<p>证明一下：</p>
<ol>
<li>首先6x肯定不是质数，因为它能被6整除；</li>
<li>其次6x+2肯定也不是质数，因为它还能被2整除；</li>
<li>依此类推，6x+3肯定能被3整除；6x+4肯定能被2整除；</li>
<li>那么，就只有6x+1和6x+5(即等同于6x-1)可能是质数了。</li>
</ol>
<h3>1.2 求1~n的所有素数</h3>
<ul>
<li>一般线性筛选法</li>
</ul>
<pre><code>#include &lt;iostream&gt;
using namespace std;

const int maxn = 100000005;
int used[maxn],number[maxn];

int prime(int n){
    int cnt=0;
    for(int i=2;i&lt;=n;i++){
        if(!used[i]){
            cnt++;
            number[cnt]=i;
        }
        for(int j=i*i;j&lt;=n;j+=i){
            used[j]=true;
        }
    }
    return cnt;
}

int main(){
    
    int cnt = prime(100);
    
    for(int i=1;i&lt;=cnt;i++)
        cout &lt;&lt; number[i] &lt;&lt; endl;
    
    return 0;
}
</code></pre>

<p>used</p>
<table>
<thead>
<tr>
	<th>2</th>
	<th>3</th>
	<th>4</th>
	<th>5</th>
	<th>6</th>
	<th>7</th>
	<th>8</th>
	<th>9</th>
	<th>10</th>
	<th>11</th>
	<th>12</th>
	<th>13</th>
	<th>14</th>
	<th>15</th>
	<th>16</th>
	<th>17</th>
	<th>18</th>
	<th>19</th>
	<th>20</th>
	<th>21</th>
	<th>22</th>
	<th>23</th>
	<th>24</th>
	<th>25</th>
	<th>26</th>
	<th>27</th>
	<th>28</th>
	<th>29</th>
	<th>30</th>
	<th>31</th>
	<th>32</th>
</tr>
</thead>
<tbody>
<tr>
	<td></td>
	<td></td>
	<td>1</td>
	<td></td>
	<td>1</td>
	<td></td>
	<td>1</td>
	<td>2</td>
	<td>1</td>
	<td></td>
	<td>1,2</td>
	<td></td>
	<td>1</td>
	<td>2</td>
	<td>1</td>
	<td></td>
	<td>1,2</td>
	<td></td>
	<td>1</td>
	<td>2</td>
	<td>1</td>
	<td></td>
	<td>1,2</td>
	<td>3</td>
	<td>1</td>
	<td>2</td>
	<td>1</td>
	<td></td>
	<td>1,2,3</td>
	<td></td>
	<td>1</td>
</tr>
</tbody>
</table>
<p>number</p>
<table>
<thead>
<tr>
	<th>1</th>
	<th>2</th>
	<th>3</th>
	<th>4</th>
	<th>5</th>
	<th>6</th>
	<th>7</th>
	<th>8</th>
	<th>9</th>
	<th>10</th>
	<th>11</th>
</tr>
</thead>
<tbody>
<tr>
	<td>2</td>
	<td>3</td>
	<td>5</td>
	<td>7</td>
	<td>11</td>
	<td>13</td>
	<td>17</td>
	<td>19</td>
	<td>23</td>
	<td>29</td>
	<td>31</td>
</tr>
</tbody>
</table>
<p>这种方法比较好理解，初始时，假设全部都是素数，当找到一个素数时，显然这个素数乘上另外一个数之后都是合数。但仔细分析能发现，这种方法会造成重复筛除合数，影响效率。比如30，在i=2的时候，k=2*15筛了一次；在i=5，k=5*6的时候又筛了一次。所以，也就有了快速线性筛法。</p>
<ul>
<li>快速线性筛选法</li>
</ul>
<pre><code>#include &lt;iostream&gt;
using namespace std;

const int maxn = 100000005;
int used[maxn],number[maxn];

int prime(int n){
    int cnt=0;
    for(int i=2;i&lt;=n;i++){
        if(!used[i]){
            cnt++;
            number[cnt]=i;
        }
        for(int j=1;(j&lt;=cnt)&amp;&amp;(i*number[j]&lt;=n);j++){
            used[i*number[j]]=true;
            if(i%number[j]==0)  //如i=6,则number[]={2,3,5},那么会用2*6消除12 
                break;          //但不会继续用3*6消除18，因为18会被i=9时消除 
        }
    }
    return cnt;
}

int main(){
    
    int cnt = prime(100);
    
    for(int i=1;i&lt;=cnt;i++)
        cout &lt;&lt; number[i] &lt;&lt; endl;
    
    return 0;
}
</code></pre>

<p>used</p>
<table>
<thead>
<tr>
	<th>2</th>
	<th>3</th>
	<th>4</th>
	<th>5</th>
	<th>6</th>
	<th>7</th>
	<th>8</th>
	<th>9</th>
	<th>10</th>
	<th>11</th>
	<th>12</th>
	<th>13</th>
	<th>14</th>
	<th>15</th>
	<th>16</th>
	<th>17</th>
	<th>18</th>
	<th>19</th>
	<th>20</th>
	<th>21</th>
	<th>22</th>
	<th>23</th>
	<th>24</th>
	<th>25</th>
	<th>26</th>
	<th>27</th>
	<th>28</th>
	<th>29</th>
	<th>30</th>
	<th>31</th>
	<th>32</th>
</tr>
</thead>
<tbody>
<tr>
	<td></td>
	<td></td>
	<td>2</td>
	<td></td>
	<td>3</td>
	<td></td>
	<td>4</td>
	<td>3</td>
	<td>5</td>
	<td></td>
	<td>6</td>
	<td></td>
	<td>7</td>
	<td>5</td>
	<td>8</td>
	<td></td>
	<td>9</td>
	<td></td>
	<td>10</td>
	<td>7</td>
	<td>11</td>
	<td></td>
	<td>12</td>
	<td>5</td>
	<td>13</td>
	<td>9</td>
	<td>14</td>
	<td></td>
	<td>15</td>
	<td></td>
	<td>16</td>
</tr>
</tbody>
</table>
<p>number</p>
<table>
<thead>
<tr>
	<th>1</th>
	<th>2</th>
	<th>3</th>
	<th>4</th>
	<th>5</th>
	<th>6</th>
	<th>7</th>
	<th>8</th>
	<th>9</th>
	<th>10</th>
	<th>11</th>
</tr>
</thead>
<tbody>
<tr>
	<td>2</td>
	<td>3</td>
	<td>5</td>
	<td>7</td>
	<td>11</td>
	<td>13</td>
	<td>17</td>
	<td>19</td>
	<td>23</td>
	<td>29</td>
	<td>31</td>
</tr>
</tbody>
</table>
<h2>2. GCD与LCM</h2>
<h3>2.1 GCD：最大公约数</h3>
<ol>
<li>
辗转相除法（欧几里德法）
<pre><code>int gcd1(int a,int b){
    if(a%b==0)
        return b;
    return gcd1(b,a%b);
}
</code></pre>

<pre><code>int gcd2(int a,int b){
    int r=a%b;
    while(r){
        a=b;
        b=r;
        r=a%b;
    }
    return b;
}
</code></pre>

</li>
<li>
穷举法
<pre><code>int gcd3(int a, int b){
    int temp=(a&gt;b)?b:a;
    while(temp&gt;0){
        if(a%temp==0&amp;&amp;b%temp==0)
            break;
        temp--; 
    } 
    return temp;
}
</code></pre>

</li>
<li>
更相减损法
<pre><code>int gcd4(int m,int n){
    int i=0,temp,x=1;
    while(m%2==0&amp;&amp;n%2==0){
        m/=2;
        n/=2;
        i+=1;
    }
    if(m&lt;n){
        temp = m;
        m=n;
        n = temp;
    }
    while(x){
        x=m-n;
        m=(n&gt;x)?n:x;
        n=(n&lt;x)?n:x;
        if(n==(m-n)) break;
    }
    if(i==0)
        return n;
    else
        return (int) pow(2,i)*n;
} 
</code></pre>

</li>
<li>
Stein
<pre><code>int gcd5(unsigned int x, unsigned int y){
    int factor = 0,temp;
    if(x &lt; y){
        temp = x;
        x = y;
        y = temp;
    }
    if ( 0 == y )
        return 0;
    while (x!=y){
        if (x &amp; 0x1 ){          /* when x is odd */
            if( y &amp; 0x1 ){      /* when x and y are both odd */
                y = (x - y) &gt;&gt; 1;
                x -= y;
            }else{              /* when x is odd and y is even */
                y &gt;&gt;= 1;
            }
        }else{                  /* when x is even */
            if ( y &amp; 0x1 ){     /* when x is even and y is odd */
                x &gt;&gt;= 1;
                if ( x &lt; y ){
                    temp = x;
                    x = y;
                    y = temp;
                }
            }else{              /* when x and y are both even */
                x &gt;&gt;= 1;
                y &gt;&gt;= 1;
                ++factor;
            }
        }
    }
    return x &lt;&lt; factor;
}
</code></pre>

</li>
</ol>
<h3>2.2 LCM：最小公倍数</h3>
<pre><code>int lcm1(int a,int b){
    int i;
    if(a&lt;b)
        swap(a,b);
    for(i=a;;i++){
        if(i%a==0 &amp;&amp;i%b==0){
            break;
        }
    }
    return i;
}
</code></pre>

<h3>2.3 GCD与LCM的关系</h3>
<ol>
<li>\( gcd(a,b) \times lcm(a,b) = a \times b  \)</li>
<li>\( lcm(a,b) = \frac{a \times b}{gcd(a,b)} = \frac{a}{gcd(a,b)} \times b \)</li>
</ol>
<pre><code>int lcm2(int a,int b){
    return a / gcd(a,b) * b;
}
</code></pre>

<h3>2.4 GCD与LCM满足分配率</h3>
<ol>
<li>gcd(a,lcm(b,c)) = lcm(gcd(a,b),gcd(a,c))</li>
<li>lcm(a,gcd(b,c)) = gcd(lcm(a,b),lcm(a,c))</li>
</ol>
<h3>2.5 例一：格点问题</h3>
<p>在第一象限的格点(x，y), (x,y&gt;=0)除原点外，能够被原点看到，当且仅当(x,y)与原点的连线不经过其他的格点。</p>
<p><img src="images/example-01.png" /></p>
<p>现给定正整数N，请计算纵坐标等于N的一行中有多少个(x,y)能够被原点看到。其中（0&lt;=x&lt;=N）</p>
<h4>Sample Input</h4>
<pre><code>5
10
</code></pre>

<h4>Sample Output</h4>
<pre><code>4
4
</code></pre>

<h4>Sample Code</h4>
<p>对于纵坐标N=10我们发现可以被看见的点是(1,10)、(3,10)、(7,10)、(9,10)其他点看不到的原因是，比如(4,10)点一定被(2,5)这一点遮挡。所以我们可以看得出我们需要求的就是gcd(i,N)==1的数。</p>
<p><strong>注意：</strong> 在座标里，将点(0, 0)和(a, b)连起来，通过整数座标的点的数目（除了(0, 0)一点之外）就是gcd(a, b)。 </p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

int gcd(int a,int b){
    int r = a%b;
    while(r){
        a = b;
        b = r;
        r = a % b;
    }
    return b;
}

int n,ans=0;

int main(){
    cin &gt;&gt; n;
    
    for(int i=1;i&lt;=n;i++){
        if(gcd(i,n)==1){
            ans ++;
        }
    }
    
    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>

<h3>2.6 例二：[NOIP2001普及组]最大公约数和最小公倍数问题</h3>
<p>输入2个正整数x,y(2≤x≤100000，2≤y≤1000000)，求出满足下列条件的P、Q的个数。 条件: </p>
<ol>
<li>P、Q是正整数 </li>
<li>要求P、Q以x为最大公约数，以y为最小公倍数。</li>
</ol>
<p>试求，满足条件的所有可能的两个正整数的个数。</p>
<h4>输入格式</h4>
<p>2个正整数x,y</p>
<h4>输出格式</h4>
<p>1个数，表示求出满足条件的P,Q的个数</p>
<h4>输入样例</h4>
<pre><code>3 60
</code></pre>

<h4>输出样例</h4>
<pre><code>4
</code></pre>

<ol>
<li>3,60</li>
<li>15,12</li>
<li>12,15</li>
<li>60,3</li>
</ol>
<h4>样例代码</h4>
<p>我们知道P*Q/x=y,那么P*Q=x*y；
我们假设枚举P，那么Q=x*y/P,然后验证P、Q是否满足条件的要求，满足就是计数</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

int x,y,p,q,ans=0;

int gcd(int a,int b){
    int r=a%b;
    while(r){
        a = b;
        b = r;
        r = a%b;
    }
    return b;
}

int lcm(int a,int b){
    return a / gcd(a,b) * b;
}

int main(){

    cin &gt;&gt; x &gt;&gt; y;
    
    for(p=1;p&lt;=y;p++){
        q = y / p * x;
        if(gcd(p,q)==x &amp;&amp; lcm(p,q)==y){
            ans ++;
        }
    }
    
    cout &lt;&lt; ans &lt;&lt; endl;
    
    return 0;
}
</code></pre>


</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
