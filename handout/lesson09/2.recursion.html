<!DOCTYPE html>
<html>
<head>
<title>2.recursion</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
<script type="text/javascript" src="http://tajs.qq.com/stats?sId=66487575" charset="UTF-8"></script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
</head>
<body>
<h1>递归算法</h1>
<h2>1. 前n项和</h2>
<p>给定n(n&gt;=1)，用递归的方法计算1+2+3+...+(n-1)+n。</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

int n;
int f(int);

int main(){

    cin &gt;&gt; n;
    cout &lt;&lt; f(n) &lt;&lt; endl;

    return 0;
}

int f(int x){
    if(x==1) return 1;
    return x+f(x-1);
}
</code></pre>

<h2>2. 斐波那契数列</h2>
<p>满足 \(F_1 = F_2 = 1, F_n = F_{n-1} + F_{n-2} \) 的数列称为斐波那契数列(Fibonacci)，它的前若干项是1,1,2,3,5,8,13,21,34,....求词数列第n项(n&gt;=3)。</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

int n;
int f(int);

int main(){

    cin &gt;&gt; n;
    cout &lt;&lt; f(n) &lt;&lt; endl;

    return 0;
}

int f(int x){
    if(x==1||x==2) return 1;
    return f(x-1)+f(x-2);
}
</code></pre>

<h2>3. 最大公约数</h2>
<p>给定两个正整数a,b求它们的最大公约数gcd(a,b)。</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

int a,b;
int gcd(int,int);

int main(){

    cin &gt;&gt; a &gt;&gt; b;
    cout &lt;&lt; gcd(a,b) &lt;&lt; endl;

    return 0;
}

int gcd(int x,int y){
    if(x%y==0) return y;
    return gcd(y,x%y);
}
</code></pre>

<h2>4. 逆波兰式求解</h2>
<p>逆波兰表达式是一种把运算符前置的算术表达式，例如普通的表达式2 + 3的逆波兰表示法为+ 2 3。
逆波兰表达式的优点是运算符之间不必有优先级关系，也不必用括号改变运算次序，
例如(2 + 3) * 4的逆波兰表示法为* + 2 3 4。
本题求解逆波兰表达式的值，其中运算符包括+ - * /四个。</p>
<ol>
<li>输入：输入为一行，其中运算符和运算数之间都用空格分隔，运算数是浮点数。</li>
<li>输出：输出为一行，表达式的值。可直接用printf(&quot;%f\n&quot;, v)输出表达式的值v。</li>
<li>样例输入：* + 11.0 12.0 + 24.0 35.0</li>
<li>样例输出：1357.000000</li>
<li>提示：可使用atof(str)把字符串转换为一个double类型的浮点数。atof定义在math.h中。此题可使用函数递归调用的方法求解。</li>
</ol>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cmath&gt;
using namespace std;

string s;
double f();

int main(){

    printf(&quot;%f&quot;,f());

    return 0;
}

double f(){
    cin &gt;&gt; s;
    if(s==&quot;+&quot;)      return f()+f();
    else if(s==&quot;-&quot;) return f()-f();
    else if(s==&quot;*&quot;) return f()*f();
    else if(s==&quot;/&quot;) return f()/f();
    else return atof(s.c_str()); 
}
</code></pre>

<h2>5. 递归二分</h2>
<p>设有n个数已经按从大到小的顺序排列，现在输入x，判断它是否在这n个数中，如果存在则输出“YES”，否则输出“NO”。</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

int a[100],n,x,lft,rgt;
void search(int,int,int);

int main(){
    cin &gt;&gt; n;
    lft = 0;
    rgt = n-1;
    for(int i=0;i&lt;n;i++)
        cin &gt;&gt; a[i];
    
    cin &gt;&gt;x;
    search(x,lft,rgt);

    return 0;
}

void search(int x,int l,int r){
    if(l&lt;=r){
        int mid = (l+r)/2;
        if(a[mid]==x){
            cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
            return;
        }else{
            if(a[mid]&gt;x)
                search(x,mid+1,r);
            else
                search(x,l,mid-1);
        }
    }else{
        cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
    }
}
</code></pre>

<h2>6. Hanoi 汉诺塔问题</h2>
<p>有n个圆盘，依半径大小（半径都不同），自下而上套在a柱上，每次只允许移动最上面一个盘子到另外的柱子上去（除a柱外，还有b柱和c柱，开始时这两个柱子上无盘子），但绝不允许发生柱子上出现大盘子在上小盘子在下的情况。现要求设计将a柱子上n个盘子搬移到c柱去的方法。</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

int k=0,n;
void move(int,char,char, char);

int main(){
    
    cin &gt;&gt; n;
    move(n,'a','b','c');

    return 0;
}

void move(int n,char a,char c,char b){
    if(n==0) return;
    move(n-1,a,b,c);
    cout &lt;&lt; ++k &lt;&lt; &quot;: &quot; &lt;&lt; a &lt;&lt; &quot;-&gt;&quot; &lt;&lt; n &lt;&lt; &quot;-&gt;&quot; &lt;&lt; c &lt;&lt; endl;
    move(n-1,b,a,c);    
}
</code></pre>

<h2>7. 集合的划分</h2>
<p>设S是一个具有n个元素的集合，\( S=\{a_1,a_2,...,a_n\} \)，现将S划分成k个满足下列条件的子集合\( S_1,S_2,...,S_K  \)，且满足：</p>
<ol>
<li>\( S_i \neq \emptyset  \)</li>
<li>\( S_i \bigcap S_j = \emptyset  (1 \leq i,j \leq k , i \neq j )  \)</li>
<li>\( S_1 \bigcup S_2 \bigcup S_3 \bigcup \cdots \bigcup S_k = S \)</li>
</ol>
<p>则称\( S_1,S_2,S_3,\cdots,S_k  \)是集合S的一个划分。他相当于把S集合中的n个元素\( a_1,a_2,\cdots,a_n  \)放入k个(0&lt;k&lt;=n&lt;30)无标号的盒子中，使得没有一个盒子为空。请你确定n个元素\( a_1,a_2,\cdots,a_n  \)放入k个无标号盒子中去的划分数S(n,k)。</p>
<ul>
<li>输入样例： 10 6 </li>
<li>输出样例： 22827</li>
<li>
算法分析：
<ol>
<li>\( S(n,k)=S(n-1,k-1) + k*S(n-1,k),(n&gt;k,k&gt;0) \)</li>
<li>\( S(n,k)=0,(n&lt;k) or (k=0) \)</li>
<li>\( S(n,k)=1,(k=1) or (k=n) \)</li>
</ol>
</li>
</ul>
<pre><code>#include &lt;iostream&gt;
using namespace std;

int n,k;
int s(int,int);

int main(){
    
    cin &gt;&gt; n &gt;&gt; k;
    cout &lt;&lt; s(n,k) &lt;&lt; endl;
    
    return 0;
}

int s(int n,int k){
    if((n&lt;k)||(k==0)) 
        return 0;
    if((k==1)||(k==n))
        return 1;
    return s(n-1,k-1) + k*s(n-1,k);
}
</code></pre>

<h2>8. 数的技术(Noip 2001)</h2>
<p>我们要求找出具有下列性质数的个数（包括输入的自然数n）。先输入一个自然数n(n&lt;=1000)，然后对此自然数按照如下方法进行处理：</p>
<ol>
<li>不做任何处理</li>
<li>在它的左边加上一个自然数，但该自然数不能超过原数的一半</li>
<li>加上数后，继续按此规则进行处理，直到不能再加自然数为止</li>
</ol>
<h3></h3>
<ul>
<li>输入格式：n(n&lt;=1000)</li>
<li>输出格式：满足条件的数</li>
<li>样例输入：6</li>
<li>样例输出：6</li>
<li>样例分析：6,16,26,126,36,136</li>
</ul>
<h3>递归方法</h3>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int ans=0;

void dfs(int m){
    ans++;
    for(int i=1;i&lt;=m/2;i++){
        dfs(i);
    }
    cout &lt;&lt; &quot;,&quot;;
}

int main(){
    int n;
    
    cin &gt;&gt; n;
    dfs(n);
    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}

</code></pre>

<h3>记忆化搜索</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

int h[1001];

void dfs(int m){
    if(h[m]!=-1)
        return;
    h[m]=1;
    for(int i=1;i&lt;=m/2;i++){
        dfs(i);
        h[m]=h[m]+h[i];
    }
}

int main(){
    int n;
    memset(h,-1,sizeof(h));
    
    cin &gt;&gt; n;
    dfs(n);
    cout &lt;&lt; h[n] &lt;&lt; endl;
    
    return 0;
}
</code></pre>

<h3>递推方法一</h3>
<p>\( h(i)=h(1)+h(2)+ \cdots +h(i/2) \)</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

int h[10001];

int main(){
    int n;
    
    cin &gt;&gt; n;
    for(int i=1;i&lt;=n;i++){
        h[i]=1;
        for(int j=1;j&lt;=i/2;j++)
            h[i]+=h[j];
    }
    cout &lt;&lt; h[n] &lt;&lt; endl;
    
    return 0;
}
</code></pre>

<h3>递推方法二</h3>
<p>已知\( h(i)=h(1)+h(2)+ \cdots +h(i/2) \)，
令\( s(x)=h(1)+h(2)+ \cdots +h(x) \) ，
则\( h(x)=s(x)-s(x-1) \)，\( h(i)=1+s(i/2) \)。</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

int h[1001],s[1001];

int main(){
    int n;
    
    cin &gt;&gt; n;
    for(int i=1;i&lt;=n;i++){
        h[i]=1+s[i/2];
        s[i]=s[i-1]+h[i];
    }
    cout &lt;&lt; h[n] &lt;&lt; endl;
    
    return 0;
}
</code></pre>

<h3>递推方法三</h3>
<p>由h(1)=1,h(2)=2,h(3)=2,h(4)=4,h(5)=4,h(6)=6,h(7)=6,h(8)=10,h(9)=10,...,可知：</p>
<ol>
<li>h(i)=h(i-1)，当i为奇数时</li>
<li>h(i)=h(i-1)+h(i/2)，当i为偶数时</li>
</ol>
<pre><code>#include &lt;iostream&gt;
using namespace std;

int h[1001];

int main(){
    int n;
    
    cin &gt;&gt; n;
    h[1]=1;
    for(int i=2;i&lt;=n;i++){
        h[i]=h[i-1];
        if(i%2==0) 
            h[i]=h[i-1]+h[i/2];
    }
    cout &lt;&lt; h[n] &lt;&lt; endl;
    
    return 0;
}
</code></pre>


</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
